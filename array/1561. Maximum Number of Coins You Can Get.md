# 1561. Maximum Number of Coins You Can Get.md

**ENG:** There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

1. In each step, you will choose any 3 piles of coins (not necessarily consecutive).
2. Of your choice, Alice will pick the pile with the maximum number of coins.
3. You will pick the next pile with the maximum number of coins.
4. Your friend Bob will pick the last pile.
5. Repeat until there are no more piles of coins.

Given an array of integers piles where piles[i] is the number of coins in the ith pile.
Return the maximum number of coins that you can have.

**RU:** Имеется 3n стопок монет разного размера. Вы и ваши друзья будете собирать стопки монет следующим образом:

1. На каждом этапе вы будете выбирать любые 3 стопки монет (не обязательно подряд).
2. По вашему выбору Алиса выберет стопку с максимальным количеством монет.
3. Вы выберете следующую стопку с максимальным количеством монет.
4. Ваш друг Боб выберет последнюю стопку.
5. Повторяйте до тех пор, пока кучки монет не закончатся.

Дан массив целых чисел, где Pils[i] — количество монет в i-й стопке. Верните максимальное количество монет, которое вы можете иметь.


### Example 1
```
Input: piles = [2,4,1,2,7,8]
Output: 9
```
**Explanation:** 
```
Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
```

### Example 2
```
Input: piles = [2,4,5]
Output: 4
```
### Example 3
```
Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
```

### Constraints
```
3 <= piles.length <= 105
piles.length % 3 == 0
1 <= piles[i] <= 104
```
## Solution 1
Примитивный подход 
### Step 1: Approach
Попробуем подумать. Будем отталкиваться от условий. 
1. По вашему выбору Алиса выберет стопку с максимальным количеством монет.
2. Вы выберете следующую стопку с максимальным количеством монет.
4. Ваш друг Боб выберет последнюю стопку.
То есть нужно, чтобы Боб остался лохом. Для этого надо забрать самые большие числа после Алисы, а самые маленькие скормить Бобу.
  
3. На каждом этапе вы будете выбирать любые 3 стопки монет (не обязательно подряд).
О, супер. Это значит, что я могу отсортировать массив.

Можно сложить профит всех и после сравнить, но толку, если в заданных условиях всегда будет один и тот же результат. Поэтому сделаем что-то типа скользящего окна для пропусков лосей.  

Этот подход называется **Жадный выбор**. Это метод решения задач, который строит решение шаг за шагом, на каждом шаге делая локально оптимальный выбор с надеждой на то, что последовательность локально оптимальных решений приведет к глобально оптимальному решению. Основная идея жадных алгоритмов заключается в том, чтобы на каждом этапе выбрать наилучший вариант, не оглядываясь на возможные последствия

**Преимущества жадных алгоритмов**
1. Простота реализации: Жадные алгоритмы часто легко понять и реализовать.
2. Эффективность: Для многих задач жадные алгоритмы работают очень быстро, часто за линейное или логарифмическое время.
3. Оптимальность: В некоторых задачах жадные алгоритмы гарантированно находят оптимальное решение (например, задачи о рюкзаке, если предметы можно делить).

**Недостатки жадных алгоритмов**
1. Отсутствие глобальной оптимальности: Жадные алгоритмы не всегда приводят к глобально оптимальному решению, особенно если локально оптимальный выбор не ведет к глобально оптимальному решению.
2. Необходимость доказательства: Для каждой задачи необходимо доказать, что жадный алгоритм действительно дает оптимальное решение, что не всегда очевидно.

Жадные алгоритмы — мощный инструмент, но их применение требует тщательного анализа, чтобы убедиться, что они действительно подходят для данной задачи.

### Step 2: Code
```ts
function maxCoins(piles: number[]): number {
  piles.sort((a,b) => a - b);
  let profit = 0, n = piles.length;
  for(let i = n / 3; i < n; i+=2){
    profit += piles[i];
  }
  return profit;
};
```

### Complexity
1. Временная сложность: $O(nlogn)$ из-за сортировки массива.
2. Пространственная сложность: $O(1)$ из-за использования фиксированного количества дополнительных переменных.

![image](https://github.com/shkvik/leet-code/assets/75574213/0da409a5-123b-4c8d-830e-bf03aef39e44)
