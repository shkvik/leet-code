# MergeSort
**Merge Sort** - Это эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй". Он был разработан Джоном фон Нейманом в 1945 году.

Принцип работы сортировки слиянием:

### 1. Разделение (Divide): 
Исходный массив разбивается на две половины.
### 2. Рекурсивная сортировка (Conquer):
Каждая из половин рекурсивно сортируется с использованием того же алгоритма.
### 3. Слияние (Merge):
Отсортированные подмассивы объединяются в один целый отсортированный массив.

Процесс повторяется до тех пор, пока не останется один элемент в каждом подмассиве. Таким образом, мы рекурсивно сортируем и объединяем массивы, пока не получим полностью отсортированный массив.
## Disassemble
Разберем каждый шаг алгоритма на примере языка c++. В анчале у нас есть верхнеуровненвая функция, чтобы программисту было удобно в далнейшем её использовать.
```cpp
vector<int> MergeSort(const vector<int>& arr) {
    if (std::is_sorted(arr.begin(), arr.end()) || arr.size() < 2)
        return arr;
    auto result = vector<int>(arr);
    mergeSort(result, 0, arr.size() - 1);
    return result;
}
```
Также неплохо было бы снизить затраты и проверить, что входящий массив есть смысл сортировать
```cpp
if (std::is_sorted(arr.begin(), arr.end()) || arr.size() < 2)
        return arr;
```
Дальше заглянем внутрть в функцию нижнего уровня ```mergeSort```
```cpp
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        //Находим середину массива
        auto mid = left + (right - left) / 2;
        // Рекурсивно сортируем две половины
        mergeSort(arr, left, mid);    //call merge left
        mergeSort(arr, mid+1, right); //call merge right
        merge(arr, left, mid, right); //call merge
    }
}
```
Сразу было бы неплохо разобрать сам метод, функция является рекурсивной, и она будет выполнятся до тех пор, пока левый указать не станет меньше правого (метод двух указателй). Каждый разы мы находим текущю середину массива, который собираемся сортировать. Данный метод не является параллельным, и следовало бы понять порядок вызовов.
### Schema
<p align="center">
<img src="https://github.com/shkvik/leet-code/assets/75574213/c714eac0-78a6-46b3-b79b-91dd643a7ffe"
</p>

С одной стороны, картинка с логикой очевидна, однако, нужно понять как это работает в коде. Разберем данный пример. 
    
1. На вход мы принимает массив, длиной 8.
2. Если мы можем с чем сравнивать, мы заходим. 
3. Далее мы вызывает эту жу функцию, когда мы сместили центр поиска. Предыдущая функция всё также осталась ждать на стеке.
4. По сути, мы так продолжаем долбится, вызывая эту функцию, пока нас не выкинет из условий.
5. Когда мы достигли того, левый указатель стал уже не меньше правого (предыдущей середины), и мы уже начинаем долбитья в правую сторону.
6. Все ранее вызванные функции остаются в стеке ждать, что же там сделают новые вызванные. (Ровно как и предыдущие, смесить на середину и ждать, пока можно будет смерджить)
7. Теперь самое хитрое, когда и правая простыня додолбилась, вызывается наш долгожданный алгоритм.

```cpp
void merge(std::vector<int>& arr, int left, int mid, int right) {
    //размеры временных массивов
    int n1 = mid - left + 1;
    int n2 = right - mid;
    // Создаем временные массивы
    std::vector<int> leftArray(n1);
    std::vector<int> rightArray(n2);
    // Копируем данные во временные массивы leftArray[] и rightArray[]
    for (int i = 0; i < n1; ++i)
        leftArray[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        rightArray[j] = arr[mid + 1 + j];
    // Слияние временных массивов обратно в arr[left..right]
    int i = 0; // Индекс первого подмассива
    int j = 0; // Индекс второго подмассива
    int k = left; // Индекс объединенного подмассива
    while (i < n1 && j < n2) {
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            ++i;
        }
        else {
            arr[k] = rightArray[j];
            ++j;
        }
        ++k;
    }
    // Копирование оставшихся элементов leftArray[], если такие есть
    while (i < n1) {
        arr[k] = leftArray[i];
        ++i;
        ++k;
    }
    // Копирование оставшихся элементов rightArray[], если такие есть
    while (j < n2) {
        arr[k] = rightArray[j];
        ++j;
        ++k;
    }
}
```
Согласитесь, получилась длинная простыня. Надо разобрать пошагово.
### 1. Находим индексы временных массивов
1. Найдём размеры для временных массив, не забывая учитывать, что первый элемент находится по индексу 0
2. Копируем данные из исходного массива, также не забывая про индексы
3. Далее мы собираемся итерироваться по массивам через циклы ```while```, поэтому нам также потребуется индексы для них
```cpp
    //размеры временных массивов
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Создаем временные массивы
    std::vector<int> leftArray(n1);
    std::vector<int> rightArray(n2);

    // Копируем данные во временные массивы leftArray[] и rightArray[]
    for (int i = 0; i < n1; ++i)
        leftArray[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        rightArray[j] = arr[mid + 1 + j];

    // Слияние временных массивов обратно в arr[left..right]
    int i = 0; // Индекс первого подмассива
    int j = 0; // Индекс второго подмассива
    int k = left; // Индекс объединенного подмассива
```
### 2. Кишки алгоритма
Добрались до самого главного, начинаем итерироваться. Если долго смотреть на код, то возникнет логичный вопрос, а что будет с элементами массива, которые не смогли попасть в сравнение? Об этом мы тоже позаботимся, но не в рамках этого цикла 
```cpp
while (i < n1 && j < n2) {
    if (leftArray[i] <= rightArray[j]) {
        arr[k] = leftArray[i];
        ++i;
    }
    else {
        arr[k] = rightArray[j];
        ++j;
    }
    ++k;
}
```
Логика такая, что мы проходимся по двум массивам и записываем результат сравнения в исходный массив. Недостаток всего этого в том, что необходимо следить за индексами вручную.
<p align="center">
<img src="https://github.com/shkvik/leet-code/assets/75574213/1e519ee0-f3a5-4b02-bc1a-e34c81ffeb70"
</p>
    
После того, как мы прошлись по всем вариантам, у нас, возможно, останется отсортированный кусок, который также необходимо добавить в конец, делается это таким образом


    
```cpp
// Копирование оставшихся элементов leftArray[], если такие есть
while (i < n1) {
    arr[k] = leftArray[i];
    ++i;
    ++k;
}

// Копирование оставшихся элементов rightArray[], если такие есть
while (j < n2) {
    arr[k] = rightArray[j];
    ++j;
    ++k;
}
```
Поздравляю, вы отсортировали массив, полный код предоставлен ниже
```cpp
#include <vector>;
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    //размеры временных массивов
    int n1 = mid - left + 1;
    int n2 = right - mid;
    // Создаем временные массивы
    vector<int> leftArray(n1);
    vector<int> rightArray(n2);
    // Копируем данные во временные массивы leftArray[] и rightArray[]
    for (int i = 0; i < n1; ++i)
        leftArray[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        rightArray[j] = arr[mid + 1 + j];
    // Слияние временных массивов обратно в arr[left..right]
    int i = 0; // Индекс первого подмассива
    int j = 0; // Индекс второго подмассива
    int k = left; // Индекс объединенного подмассива
    while (i < n1 && j < n2) {
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            ++i;
        }
        else {
            arr[k] = rightArray[j];
            ++j;
        }
        ++k;
    }
    // Копирование оставшихся элементов leftArray[], если такие есть
    while (i < n1) {
        arr[k] = leftArray[i];
        ++i;
        ++k;
    }
    // Копирование оставшихся элементов rightArray[], если такие есть
    while (j < n2) {
        arr[k] = rightArray[j];
        ++j;
        ++k;
    }
}

void mergeSort(vector<int>& arr, int left, int right)
{
    if (left < right) {
        //Находим середину массива
        auto mid = left + (right - left) / 2;     
        // Рекурсивно сортируем две половины
        mergeSort(arr, left, mid);
        mergeSort(arr, mid+1, right);
        merge(arr, left, mid, right);
    }
}

vector<int> MergeSort(const vector<int>& arr) {
    if (std::is_sorted(arr.begin(), arr.end()) || arr.size() < 2)
        return arr;
    auto result = vector<int>(arr);
    mergeSort(result, 0, arr.size() - 1);
    return result;
}
```
## Analys
### merge 
1. Создает два временных массива leftArray и rightArray, копирует данные из основного массива в них.
2. Выполняет слияние отсортированных подмассивов leftArray и rightArray в основной массив arr.
3. Время выполнения: O(n), где n - суммарный размер leftArray и rightArray.
### mergeSort 
1. Рекурсивно разбивает входной вектор на подмассивы, вызывая mergeSort для каждой половины.
2. Затем вызывает merge для слияния двух отсортированных половин.
3. Время выполнения: O(n log n), где n - размер входного массива.
### MergeSort функция (обертка)
1. Проверяет, отсортирован ли входной вектор. Если да, возвращает его же.
2. Иначе создает копию входного вектора и вызывает mergeSort для сортировки.
3. Время выполнения: O(n log n), где n - размер входного массива.
![image](https://github.com/shkvik/leet-code/assets/75574213/0da409a5-123b-4c8d-830e-bf03aef39e44)
