# MergeSort
**Merge Sort** - Это эффективный алгоритм сортировки, который использует принцип "разделяй и властвуй". Он был разработан Джоном фон Нейманом в 1945 году.

Принцип работы сортировки слиянием:

### 1. Разделение (Divide): 
Исходный массив разбивается на две половины.
### 2. Рекурсивная сортировка (Conquer):
Каждая из половин рекурсивно сортируется с использованием того же алгоритма.
### 3. Слияние (Merge):
Отсортированные подмассивы объединяются в один целый отсортированный массив.

Процесс повторяется до тех пор, пока не останется один элемент в каждом подмассиве. Таким образом, мы рекурсивно сортируем и объединяем массивы, пока не получим полностью отсортированный массив.
## Disassemble
Разберем каждый шаг алгоритма на примере языка c++. В анчале у нас есть верхнеуровненвая функция, чтобы программисту было удобно в далнейшем её использовать.
```cpp
vector<int> MergeSort(const vector<int>& arr) {
    if (std::is_sorted(arr.begin(), arr.end()) || arr.size() < 2)
        return arr;
    auto result = vector<int>(arr);
    mergeSort(result, 0, arr.size() - 1);
    return result;
}
```
Также неплохо было бы снизить затраты и проверить, что входящий массив есть смысл сортировать
```cpp
if (std::is_sorted(arr.begin(), arr.end()) || arr.size() < 2)
        return arr;
```
Дальше заглянем внутрть в функцию нижнего уровня ```mergeSort```
```cpp
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        //Находим середину массива
        auto mid = left + (right - left) / 2;
        // Рекурсивно сортируем две половины
        mergeSort(arr, left, mid);    //call merge left
        mergeSort(arr, mid+1, right); //call merge right
        merge(arr, left, mid, right); //call merge
    }
}
```
Сразу было бы неплохо разобрать сам метод, функция является рекурсивной, и она будет выполнятся до тех пор, пока левый указать не станет меньше правого (метод двух указателй). Каждый разы мы находим текущю середину массива, который собираемся сортировать. Данный метод не является параллельным, и следовало бы понять порядок вызовов.
### Schema
<p align="center">
<img src="https://github.com/shkvik/leet-code/assets/75574213/c714eac0-78a6-46b3-b79b-91dd643a7ffe"
</p>

С одной стороны, картинка с логикой очевидна, однако, нужно понять как это работает в коде. Разберем данный пример. 
    
1. На вход мы принимает массив, длиной 8.
2. Если мы можем с чем сравнивать, мы заходим. 
3. Далее мы вызывает эту жу функцию, когда мы сместили центр поиска. Предыдущая функция всё также осталась ждать на стеке.
4. По сути, мы так продолжаем долбится, вызывая эту функцию, пока нас не выкинет из условий.
5. Когда мы достигли того, левый указатель стал уже не меньше правого (предыдущей середины), и мы уже начинаем долбитья в правую сторону.
6. Все ранее вызванные функции остаются в стеке ждать, что же там сделают новые вызванные. (Ровно как и предыдущие, смесить на середину и ждать, пока можно будет смерджить)
7. Теперь самое хитрое, когда и правая простыня додолбилась, вызывается наш долгожданный алгоритм.

```cpp
void merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    // Создаем временные массивы
    std::vector<int> leftArray(n1);
    std::vector<int> rightArray(n2);
    // Копируем данные во временные массивы leftArray[] и rightArray[]
    for (int i = 0; i < n1; ++i)
        leftArray[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        rightArray[j] = arr[mid + 1 + j];
    // Слияние временных массивов обратно в arr[left..right]
    int i = 0; // Индекс первого подмассива
    int j = 0; // Индекс второго подмассива
    int k = left; // Индекс объединенного подмассива
    while (i < n1 && j < n2) {
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            ++i;
        }
        else {
            arr[k] = rightArray[j];
            ++j;
        }
        ++k;
    }
    // Копирование оставшихся элементов leftArray[], если такие есть
    while (i < n1) {
        arr[k] = leftArray[i];
        ++i;
        ++k;
    }
    // Копирование оставшихся элементов rightArray[], если такие есть
    while (j < n2) {
        arr[k] = rightArray[j];
        ++j;
        ++k;
    }
}
```
